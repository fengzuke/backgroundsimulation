//*********************************************
//  This is auto generated by G4gen 0.6
//                                  author:Qian

#include "G4LogicalVolumeStore.hh"
#include "G4LogicalVolume.hh"
#include "G4Box.hh"
#include "G4Event.hh"
#include "G4ParticleGun.hh"
#include "G4GeneralParticleSource.hh"
#include "G4ParticleTable.hh"
#include "G4ParticleDefinition.hh"
#include "G4SystemOfUnits.hh"
#include "Verbose.hh"
#include "Randomize.hh"
#include <cmath>
#include "G4RotationMatrix.hh"
#include "G4Transform3D.hh"3452
//#include "G4MTRandGauss.hh"

#include "MyGunAction.hh"
#include <iostream>
#include <cstdlib>
//#include<time.h>

#define random() (rand()/double(RAND_MAX)*M_PI)
//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

using namespace std;

MyGunAction *MyGunAction::fInstance = 0;

MyGunAction::MyGunAction()
    : G4VUserPrimaryGeneratorAction(),fParticleGun(0),fParticleSourceGun(0)
{
    if (verbose)
        G4cout << "====>MyGunAction::MyGunAction()" << G4endl;
	fPGorGPS = false; //false for GPS, true for Particle Gun

    G4int nofParticles = 1;
    fParticleGun = new G4ParticleGun(nofParticles);
    // default particle kinematic
    G4ParticleTable *particleTable = G4ParticleTable::GetParticleTable();
    G4ParticleDefinition *particle = particleTable->FindParticle("geantino");
    fParticleGun->SetParticleDefinition(particle);

    gunEng = 3 * GeV;
    gunPos = G4ThreeVector(0., 0., 0.);
    gunDirection = G4ThreeVector(0., 0., -1.);
    gunPolarization = G4ThreeVector(1., 0., 0.);

    SetParticle();
    //create a messenger for this class
    fGunMessenger = new MyGunMessenger(this);

    fRootFile = G4String("set.root");
    fTxtFile = G4String("./gif/tmp.txt");
    fProgFile = G4String("./gif/progress.txt");

	fParticleSourceGun = new G4GeneralParticleSource();
	fParticleSourceGun->SetParticleDefinition(particle);

}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

MyGunAction::~MyGunAction()
{
	delete fParticleGun;
	delete fParticleSourceGun;
	delete fGunMessenger;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void MyGunAction::SetParticle()
{
    theparax = gunPos[0];
    theparay = gunPos[1];
    theparaz = gunPos[2];
    momenDirecX = gunDirection[0];
    momenDirecY = gunDirection[1];
    momenDirecZ = gunDirection[2];

    //.. do the calculation
	//.. 0. set the angle of gaussian because of waggle satellite
	if (gaussSigma !=0){
		vval1 = G4RandGauss::shoot(0, gaussSigma); //X
		vval2 = G4RandGauss::shoot(0, gaussSigma); //Y 
		if (abs(vval1) >= 0.5 || abs(vval2) >=0.5){
			G4cout<<"the gauss sigma is probably too big."<<G4endl;
			vval1 = (vval1 > 0.5)? 0.5 : vval1;
			vval1 = (vval1 < -0.5)? -0.5 : vval1;
			vval2 = (vval2 > 0.5)? 0.5 : vval2;
			vval2 = (vval2 < -0.5)? -0.5 : vval2;
			}
		momenDirecX += vval1;
		momenDirecY += vval2;
		}
	//G4cout<<" ``// "<<gaussSigma<<" "<<vval1<<" "<<vval2<<" "<<momenDirecX<<" "<<momenDirecY<<G4endl;

		newDirection[0] = momenDirecX;
		newDirection[1] = momenDirecY;
		newDirection[2] = momenDirecZ;
    //.. 1. get the Z of window

    G4LogicalVolume *kovarLV = G4LogicalVolumeStore::GetInstance()->GetVolume("Collimation1");
    G4Box *kovarBox = NULL;
    if (kovarLV)
        kovarBox = dynamic_cast<G4Box *>(kovarLV->GetSolid());

    G4double kovarXlength = 0;
    G4double kovarYlength = 0;
    G4double kovarZlength = 60;
    G4double lunchsquareX = 0;
    G4double lunchsquareY = 0;
    G4double lunchsquareZ = 0;

    if (kovarBox)
    {
        kovarXlength = kovarBox->GetXHalfLength();
        kovarYlength = kovarBox->GetYHalfLength();
        kovarZlength = kovarBox->GetZHalfLength();
    }

    //.. 2. get the R of the projection sphere
    double R = 200 * mm; // choose a sufficient large R to make sure the detector is covered inside.

    //.. 3. calculate the projection point
    G4double sideXY = sqrt(pow(momenDirecX, 2) + pow(momenDirecY, 2));
    G4double sideXYZ = sqrt(pow(momenDirecX, 2) + pow(momenDirecY, 2) + pow(momenDirecZ, 2));
    if (sideXYZ == 0)
    {
        G4cout << "something is wrong!" << G4endl;
    }
    else
    {
        G4double angleZ_XY = acos(sideXY / sideXYZ);
        if (sideXY == 0)
        {
            lunchsquareZ = R * sin(angleZ_XY) + theparaz;
            lunchsquareX = theparax;
            lunchsquareY = theparay;
        }
        else
        {
            G4double angleXY = acos(momenDirecY / sideXY);
            lunchsquareZ = R * sin(angleZ_XY) + theparaz;
            lunchsquareX =(momenDirecX >0)? -R * cos(angleZ_XY) * sin(angleXY) + theparax : R * cos(angleZ_XY) * sin(angleXY) + theparax;
            lunchsquareY = -R * cos(angleZ_XY) * cos(angleXY) + theparay;
        }
    }
	//G4cout<<"tmp!!!!!!!! "<<lunchsquareX<<" "<<lunchsquareY<<G4endl;
    G4ThreeVector newgunPos = G4ThreeVector(lunchsquareX, lunchsquareY, lunchsquareZ); //a

    //.. 4. calculate the polarization vector
	G4double monteCarlo;
	//...4.1 calculate the Elliptical Partially polarized
	if (gunPartPolarzation < 1){
		G4double palortmp = ( 1 + gunPartPolarzation)/( 1 - gunPartPolarzation);
		G4double longAxistmp = palortmp/( 1 + palortmp);
		G4double shortAxistmp = 1 - longAxistmp;
		//G4cout<<"tmp!!!!!!!! "<<longAxistmp<<" "<<shortAxistmp<<G4endl;
		monteCarlo = rand()/double(RAND_MAX);
		//cout<<"???????? "<<gunPolarization[0]<<" "<<gunPolarization[1]<<endl;
		if (monteCarlo <= shortAxistmp)
			newPolarization = G4ThreeVector (gunPolarization[1], gunPolarization[0], 0);
		else
			newPolarization = G4ThreeVector (gunPolarization[0], gunPolarization[1], 0);
		//cout<<"!!!!!!!! "<<newPolarization[0]<<" "<<newPolarization[1]<<endl;
	}
	else if (gunPartPolarzation == 1)
		newPolarization = gunPolarization;
	//.. 4.2 calculate the polarization vector
    G4ThreeVector newaxisZ = newDirection.unit();
    G4ThreeVector newaxisY = newaxisZ.cross(G4ThreeVector(1, 0, 0));
    if (newaxisY == G4ThreeVector(0, 0, 0))
        newaxisY = G4ThreeVector(0, 0, 1);

    G4ThreeVector newaxisX = newaxisY.cross(newaxisZ);
    G4RotationMatrix rotMatrix = G4RotationMatrix(newaxisX, newaxisY, newaxisZ);
    newPola = rotMatrix * newPolarization.unit();

	//cout<<"!!!!!!!! "<<newDirection[0]<<" "<<newDirection[1]<<" "<<newDirection[2]<<endl;
    //.. 5. set the gun
    fParticleGun->SetParticleEnergy(gunEng);
    fParticleGun->SetParticleMomentumDirection(newDirection);
    fParticleGun->SetParticlePosition(newgunPos);
    fParticleGun->SetParticlePolarization(newPola);
	//G4cout<<"====+++=== "<<newPola<<G4endl;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......

void MyGunAction::GeneratePrimaries(G4Event *anEvent)
{
    if (verbose)
        G4cout << "====>MyGunAction::GeneratePrimaries()" << G4endl;
    donPDGID = fParticleGun->GetParticleDefinition()->GetPDGEncoding();
    //G4cout<<"+++++++++++++++++++++++++  "<<donPDGID<<G4endl;
	if(fPGorGPS == true){
	SetParticle();
    fParticleGun->GeneratePrimaryVertex(anEvent);
	}
	else 
		fParticleSourceGun->GeneratePrimaryVertex(anEvent);
   
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo......
